# Package installation

There are three challenges when it comes to installing R packages in production:

-   You will have to install packages on a Linux server and your primary experience is likely installing packages on a Mac or Windows desktop. There are some important differences that you need to learn about and some new vocabulary including binary packages and system libraries.

-   Production jobs are usually run in some sort of throwaway container. That means that unlike in your development environment, you need to install packages every time your production job runs. This means that the speed of package installation becomes more much important.

-   Because packages are re-installed all the time, you don't want to install the latest packages from CRAN, because they will change over time. Instead, you want to make sure that the production machine always installs the same versions, and those versions match the versions that you're using locally.

We'll tackle each of those challenges in this chapter. But if you just want a quick take away to make installing packages on Linux as easy as possible there are two things you need to do:

-   Use `pak::pak()` instead of `install.packages()`. `pak()` gives more actionable feedback if package installation fails.

-   Use [Posit Public Package Manager](https://p3m.dev) (**P3M** for short) instead of CRAN. This is a free service provided by Posit that provides R package binaries for Linux.

We'll begin by learning about pak, because it's useful for both development and deployment, regardless of what platform you're using. We'll then continue on to talk about some of the most important vocabulary you'll need to understand the difference between package installation on Mac/Windows and Linux, and then finish off by talking about how you can match deployment package versions to your development environment.

## pak

We recommend that you use `pak::pak()` to install R packages instead of `install.packages()`. It has three main properties:

-   It's **fast**: pak downloads and installs packages in parallel, making installation much faster. It also caches packages making it faster to switch between multiple versions of the same package.

-   It's **safe**: pak works out an installation plan up front, and tells you exactly what it's going to do before it does anything. It also protects you against common failure modes on Windows (e.g. a package is loaded in another session) and Linux (e.g. you are missing a system dependency).

-   It's **convenient**: as well as installing packages from CRAN, pak can also install packages from GitHub, GitLab, Biocondutor and more. It makes it easy to install historical versions of packages and works with P3M to install binaries on Linux.

Using pak is simple. First install it:

``` r
install.packages("pak")
```

And then you can supply the packages to install:

``` r
pak::pak("tidyverse")
# Install a package from GitHub
pak::pak("r-lib/rlang")
```

pak has many more capabilities that you'll can learn about in its [getting started guide](https://pak.r-lib.org/reference/get-started.html#package-installation){.uri}.

## Installing a package on Linux

When you install a package from CRAN on Mac and Windows you get a self-contained binary package:

-   **Self-contained** means that you don't need to install any other tools to make it work.

-   **Binary** means that CRAN has done all the work to get the package ready for your specific operating system. In turn that means installation happens quickly because all R needs to do is unzip a file.

Things are different on Linux because CRAN only provides source packages. That means you need to compile the package (which can take multiple minutes for complex packages) and if the package has any external dependencies, you'll need to install those before compilation will succeed. For example, take the xml2 package. Most of the work in xml2 is done in C code, and while there is some C code in xml2 itself, most of the code comes from the external libxml2 library[^packages-1]. When you install xml2 on Mac or Windows you can get a binary package that already contains the external code. If you install xml2 on Linux, you have to first install libxml2 on your computer and then compile the package (which might take a few minutes).

[^packages-1]: Confusingly the C equivalents of R's packages are called libraries.

To resolve these two problems we can use P3M and pak.

### Package binaries

This is a bit annoying if you use a Linux machine as a development machine, but it can be crippling on a production machine because the packages have to be installed every time your job starts. Luckily, you can resolve this problem by using the freely available [Posit Public Package Manager](https://p3m.dev)[^packages-2] (or P3M for short). P3M is very similar to CRAN, but also provides binaries for many popular Linux distributions, like CentOS, Rocky Linux, OpenSUSE, RHEL, SLES, Ubunutu and Debian.

[^packages-2]: We also provide the non-free Posit Package Manager which you can use inside your organisation. Using PPM typically makes your IT department happy because you're not installing code from random corners of the internet, and it makes you happy because it allows you to install all the open source data science packages (in R and Python) that you need to do your job. You can also use PPM to distribute your own internal packages. We'll come back to that later in the book.

You should ask your system administrator to configure P3M for your production systems so that it just works. If you want to do it yourself, you can following the [P3M setup instructions](https://p3m.dev/client/#/repos/cran/setup), e.g.:

``` r
options(repos = c(
  CRAN = "https://p3m.dev/cran/__linux__/bookworm/latest",
))
```

(Note that the URL varies based on the Linux distribution you use, so please don't blindly copy and paste that example!)

You might also want to use P3M in your development environment. In that case you might consider using both CRAN and P3M: that allows you to get binaries from P3M if they're available; otherwise you'll get the latest version from CRAN, which may require compiling from source. It's up to you to make the trade-off between grabbing the absolute latest version and a version that's faster to install.

``` r
options(repos = c(
  P3M  = "https://p3m.dev/cran/__linux__/bookworm/latest",
  CRAN = "https://cloud.r-project.org"
))
```

### System dependencies

Using P3M resolves the speed problem, but it doesn't give you self-contained binaries: the binaries expect system dependencies to be installed in standard locations. That's the convention on Linux servers because typically a server admin wants to control exactly what versions of system libraries are used. The most important reason is security: if your packages are using a central version of system library, it's very easy to update them all to make sure every package is protected from any security risks. It also saves a little disk space, because instead of every package having it's own copy of the system library they can all point to a common central location.

So that means you'll need to install some system dependencies in order to make some packages work. How do you know which packages need which system dependencies? That's where pak comes in. If you use `pak()` to install packages is that it will report if any system dependencies are missing, and give you actionable advice. For example, if you attempt to install the tidyverse on a fresh Linux system, you'll get an message like this:

```
→ Will install 101 packages.
→ Will download 31 CRAN packages (34.93 MB), cached: 70 (33.19 MB).

[...]

✖ Missing 11 system packages. You'll probably need to install them manually:
+ libcurl4-openssl-dev  - curl
+ libfontconfig1-dev    - systemfonts
+ libfreetype6-dev      - ragg, systemfonts, textshaping
+ libfribidi-dev        - textshaping
+ libharfbuzz-dev       - textshaping
+ libjpeg-dev           - ragg
+ libpng-dev            - ragg
+ libssl-dev            - curl, openssl
+ libtiff-dev           - ragg
+ libxml2-dev           - xml2
+ pandoc                - knitr, reprex, rmarkdown
```

You can then drop that info into a ticket to your IT department.

pak also provides tools to do this programmatically, e.g:

```{r}
pak::pkg_sysreqs("devtools", sysreqs_platform = "centos")
```

You can vary the `sysreqs_platform` to see one of the reasons that installing system dependencies is so frustrating to do by hand: every Linux distribution seems to have a slightly different name for the same system dependency.

Additionally, at Posit, we recommend that server admins install the most common set of system dependencies needed by R packages. This doesn't take up a huge amount of disk space, and it saves everyone time by installing a bunch of packages at once rather than them dribbling in one at a time via tickets. You can find that list at <https://docs.posit.co/connect/admin/r/dependencies/index.html>.

## Matching package versions

We've tackled the first challenge of installing packages on Linux. Now we need to talk about the next challenge: installing the right versions of the packages. The goal is to install the same versions of packages in your deployment environment as your development environment so that you get the same results. There are many ways you can do this, but Posit's open source and pro tools have standardised on one format: `manifest.json`.

### Capturing your current versions

The next step up (and the first place that you want to consider for any "real" job) is capturing the all the versions of all the packages (and their dependencies) that your project uses. One way to do that that's widely supported is to use `rsconnect::writeManifest()` to create `manifest.json`. This function looks through all the code in your project, identifying all the packages that it uses (whether thats with a `library()` or `require()` call, because you use `::` or something else), finds all the packages that those packages use, and then records their versions in `manifest.json`.

Connect and Connect Cloud both require this file, and GHA can use it with `setup-r-manifest`. If you're using Git-backed deploys then you'll need to create it yourself (and update it every time you install or update a package); if you're using push-button deploy, it'll be run for you automatically behind the scenes.

(TODO: how can we get `manifest.json` to automatically update itself?)

The downside of this approach is that while the versions on the deployment server are locked, the versions on your development machine are not. Imagine that you create a dashboard, and it runs successfully for a couple of years because the package versions are the same everytime you run it. When you come back to that project, the code might no longer run. We'll come back to that problem in ...

### Use the latest CRAN versions

There is another workflow available on GitHub Actions that worth talking about: installing packages from CRAN.

This is the easiest (all you need is a list of package names) but also the most dangerous (which is why it's not currently supported in connect+cloud). This style is the best fit for code that you're sharing widely, because you'll quickly find out if it doens't work with the current versions of CRAN packages. This makes it a really good fit for package development, because you want to make sure that your package always works with the latest version of CRAN packages (since you have no control over what package versions your users will install).

It can also be a good fit for short-term jobs that aren't particularly important. But you're fundamentally at the mercy of the package maintainers that you use. If you use only a small set of packages that are changing slowly or with strong backward compatibility guarantees, this is relatively low risk. But if you use a lot of packages, or packages developed by less experienced maintainers, you're much more likely to run into problems.

To use this style all you need to do record package names in your `DESCRIPTION` file ansd use the `setup-r-dependencies` step in your action.

I'd encourage you to have at least one daily job that uses this workflow. It shouldn't be a critical job, but it'll help you get a better sense of risk and reward, and it'll give you one small job that requires a regular care and feeding
